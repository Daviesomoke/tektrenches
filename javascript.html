<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Complete JavaScript guide from beginner to advanced - learn variables, functions, DOM manipulation, async programming, and more with practical examples.">
    <title>Complete JavaScript Guide - From Beginner to Advanced | TechTrenches</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    



    <nav class="navbar">

        <ul class="nav-link">

            <li> <a href="index.html"> Home </a></li>
            <li> <a href="programming.html"> programming languages </a></li>
            <li> <a href="about.html"> about </a></li>
            <li> <a href="contact.html"> contact</a></li>
            <li><a href="privacy.html">Privacy Policy</a></li>





        </ul>



    </nav>


    
    
    
        <div class="container">
            <header>
                <h1>Complete JavaScript Guide: From Beginner to Advanced</h1>
                <p style="color: #64748b; font-size: 1.1em;">Master JavaScript with practical examples, clear explanations,
                    and real-world applications</p>
            </header>
    
            <article>
                <span class="section-label">BEGINNER</span>
                <h2>What Is JavaScript and How It Works</h2>
    
                <p>Imagine you've built a beautiful house with HTML (the structure) and painted it nicely with CSS (the
                    style). Now you want the lights to turn on when you flip switches, doors to open when you turn handles,
                    and music to play when you press buttons. That's where JavaScript comes in—it makes your website come
                    alive.</p>
    
                <p>JavaScript is a programming language that runs in web browsers. While HTML creates content and CSS styles
                    it, JavaScript adds behavior and interactivity. It answers questions like: What happens when someone
                    clicks this button? How do we validate a form before submission? How do we update content without
                    refreshing the page?</p>
    
                <h3>JavaScript in the Browser: The Execution Environment</h3>
                <p>When you visit a webpage, the browser does three things in order:</p>
    
                <ol>
                    <li><strong>Parses HTML</strong> - Creates the page structure</li>
                    <li><strong>Applies CSS</strong> - Styles the elements</li>
                    <li><strong>Executes JavaScript</strong> - Adds interactivity</li>
                </ol>
    
                <p>JavaScript runs in what's called the "JavaScript engine." Different browsers use different engines
                    (Chrome uses V8, Firefox uses SpiderMonkey), but they all follow the same JavaScript standards.</p>
    
                <h3>Where JavaScript Lives in Your HTML</h3>
                <p>Like CSS, JavaScript can be added in three ways, but the approach is slightly different:</p>
    
                <pre><code>&lt;!-- Inline JavaScript (avoid this) --&gt;
    &lt;button onclick="alert('Hello!')"&gt;Click Me&lt;/button&gt;
    
    &lt;!-- Internal JavaScript (for small scripts) --&gt;
    &lt;script&gt;
        console.log('Hello from internal script!');
    &lt;/script&gt;
    
    &lt;!-- External JavaScript (professional approach) --&gt;
    &lt;script src="script.js"&gt;&lt;/script&gt;</code></pre>
    
                <div class="tip-box">
                    <strong>Best Practice:</strong> Place your <code>&lt;script&gt;</code> tags just before the closing
                    <code>&lt;/body&gt;</code> tag. This ensures the HTML is fully loaded before JavaScript tries to
                    manipulate it.
                </div>
    
                <h3>Your First JavaScript: The Console</h3>
                <p>The browser console is your best friend when learning JavaScript. It's like a playground where you can
                    test code immediately. Open it in any browser:</p>
    
                <ul>
                    <li>Chrome/Edge: Press F12 or Ctrl+Shift+J (Cmd+Option+J on Mac)</li>
                    <li>Firefox: Press F12 or Ctrl+Shift+K (Cmd+Option+K on Mac)</li>
                </ul>
    
                <pre><code>// Your first JavaScript command
    console.log('Hello, World!');
    
    // The console displays: Hello, World!</code></pre>
    
                <p><code>console.log()</code> is like JavaScript's way of talking to you. It prints messages to the console,
                    which is invaluable for debugging and understanding what your code is doing.</p>
    
                <h3>How JavaScript Executes: Line by Line</h3>
                <p>JavaScript reads your code from top to bottom, one line at a time (we call this "synchronous execution").
                    Think of it like following a recipe—you do step 1, then step 2, then step 3:</p>
    
                <pre><code>console.log('First');
    console.log('Second');
    console.log('Third');
    
    // Output:
    // First
    // Second
    // Third</code></pre>
    
                <p>This seems obvious now, but understanding execution order becomes critical when you work with functions
                    and asynchronous code later.</p>
    
                <h2>JavaScript Variables, Data Types, and Operators</h2>
    
                <p>Variables are containers that store data. Think of them as labeled boxes where you can put information
                    and retrieve it later. The label is the variable name, and what's inside the box is the value.</p>
    
                <h3>Declaring Variables: let, const, and var</h3>
                <p>JavaScript has three ways to create variables, but you should primarily use two of them:</p>
    
                <pre><code>// let - for values that can change
    let age = 25;
    age = 26; // ✓ This works
    
    // const - for values that won't change
    const birthYear = 1998;
    birthYear = 1999; // ✗ Error! Can't reassign const
    
    // var - the old way (avoid in modern code)
    var name = 'John'; // Still works but has quirks</code></pre>
    
                <div class="info-box">
                    <strong>Rule of thumb:</strong> Use <code>const</code> by default. Only use <code>let</code> when you
                    know the value will change. Never use <code>var</code> in new code—it has confusing scoping rules that
                    <code>let</code> and <code>const</code> fix.
                </div>
    
                <h3>Naming Variables: The Rules</h3>
                <p>Variable names must follow these rules:</p>
    
                <ul>
                    <li>Can contain letters, numbers, underscores, and dollar signs</li>
                    <li>Must start with a letter, underscore, or dollar sign (not a number)</li>
                    <li>Are case-sensitive (<code>age</code> and <code>Age</code> are different)</li>
                    <li>Can't use reserved words like <code>let</code>, <code>function</code>, <code>return</code></li>
                </ul>
    
                <pre><code>// Good variable names (descriptive and clear)
    let firstName = 'Sarah';
    let totalPrice = 99.99;
    let isLoggedIn = true;
    
    // Bad variable names (confusing or meaningless)
    let x = 'Sarah';     // What does x represent?
    let tp = 99.99;       // Abbreviations are cryptic
    let flag = true;      // Which flag? What does it mean?</code></pre>
    
                <h3>Data Types: Understanding What Variables Hold</h3>
                <p>JavaScript has several data types. Unlike some languages, you don't declare the type—JavaScript figures
                    it out automatically:</p>
    
                <pre><code>// String - text wrapped in quotes
    let name = 'Alice';
    let message = "Hello, world!";
    let greeting = `Hi, ${name}!`; // Template literal (can embed variables)
    
    // Number - integers and decimals
    let age = 30;
    let price = 19.99;
    let negative = -5;
    
    // Boolean - true or false
    let isActive = true;
    let hasAccount = false;
    
    // Undefined - variable declared but not assigned
    let result;
    console.log(result); // undefined
    
    // Null - intentionally empty value
    let data = null;
    
    // Object - collection of key-value pairs
    let person = {
        name: 'John',
        age: 25,
        city: 'New York'
    };
    
    // Array - ordered list of values
    let colors = ['red', 'green', 'blue'];</code></pre>
    
                <h3>Template Literals: Modern String Creation</h3>
                <p>Template literals (backticks) make creating dynamic strings much easier than concatenation:</p>
    
                <pre><code>let name = 'Sarah';
    let age = 28;
    
    // Old way (concatenation)
    let message1 = 'Hello, ' + name + '. You are ' + age + ' years old.';
    
    // New way (template literals)
    let message2 = `Hello, ${name}. You are ${age} years old.`;
    
    // Can even include expressions
    let message3 = `In 5 years, you'll be ${age + 5} years old.`;</code></pre>
    
                <h3>Type Checking with typeof</h3>
                <p>Use <code>typeof</code> to check what type a variable is:</p>
    
                <pre><code>console.log(typeof 'Hello');        // "string"
    console.log(typeof 42);             // "number"
    console.log(typeof true);           // "boolean"
    console.log(typeof undefined);      // "undefined"
    console.log(typeof {name: 'John'}); // "object"
    console.log(typeof [1, 2, 3]);      // "object" (arrays are objects!)</code></pre>
    
                <h3>Basic Operators: Doing Math and Comparisons</h3>
                <p>Operators let you perform operations on values:</p>
    
                <pre><code>// Arithmetic operators
    let sum = 10 + 5;           // 15
    let difference = 10 - 5;    // 5
    let product = 10 * 5;       // 50
    let quotient = 10 / 5;      // 2
    let remainder = 10 % 3;     // 1 (modulo - gives remainder)
    let power = 2 ** 3;         // 8 (2 to the power of 3)
    
    // Increment and decrement
    let count = 0;
    count++;  // count is now 1 (same as count = count + 1)
    count--;  // count is now 0 (same as count = count - 1)
    
    // Assignment operators
    let x = 10;
    x += 5;   // x = x + 5; (x is now 15)
    x -= 3;   // x = x - 3; (x is now 12)
    x *= 2;   // x = x * 2; (x is now 24)
    x /= 4;   // x = x / 4; (x is now 6)</code></pre>
    
                <h3>Comparison Operators: Testing Conditions</h3>
                <pre><code>// Equality (checks value only)
    5 == '5'    // true (converts string to number)
    5 != '6'    // true
    
    // Strict equality (checks value AND type)
    5 === '5'   // false (different types)
    5 === 5     // true (same value and type)
    5 !== '5'   // true (different types)
    
    // Relational operators
    10 > 5      // true
    10 < 5      // false
    10 >= 10    // true
    10 <= 5     // false</code></pre>
    
                <div class="warning-box">
                    <strong>Common Mistake:</strong> Always use <code>===</code> (strict equality) instead of
                    <code>==</code> (loose equality). Loose equality performs type conversion which can lead to confusing
                    bugs. For example: <code>0 == false</code> returns <code>true</code>, but <code>0 === false</code>
                    returns <code>false</code>.
                </div>
    
                <h3>Logical Operators: Combining Conditions</h3>
                <pre><code>// AND (&&) - both must be true
    let age = 25;
    let hasLicense = true;
    let canDrive = age >= 18 && hasLicense; // true
    
    // OR (||) - at least one must be true
    let isWeekend = true;
    let isHoliday = false;
    let canRelax = isWeekend || isHoliday; // true
    
    // NOT (!) - inverts boolean
    let isRaining = false;
    let isSunny = !isRaining; // true</code></pre>
    
                <h2>JavaScript Functions Explained</h2>
    
                <p>Functions are reusable blocks of code that perform specific tasks. Think of them as recipes—you write the
                    recipe once, then you can follow it (call it) as many times as you need without rewriting the steps.</p>
    
                <h3>Function Declaration: The Traditional Way</h3>
                <pre><code>// Define a function
    function greet(name) {
        console.log(`Hello, ${name}!`);
    }
    
    // Call (execute) the function
    greet('Alice');  // Output: Hello, Alice!
    greet('Bob');    // Output: Hello, Bob!</code></pre>
    
                <p>Breaking this down:</p>
                <ul>
                    <li><code>function</code> - keyword that declares a function</li>
                    <li><code>greet</code> - the function name</li>
                    <li><code>(name)</code> - parameter (input the function expects)</li>
                    <li><code>{ }</code> - function body (the code that runs)</li>
                </ul>
    
                <h3>Return Values: Getting Results Back</h3>
                <p>Functions can send values back using <code>return</code>:</p>
    
                <pre><code>function add(a, b) {
        return a + b;
    }
    
    let result = add(5, 3);
    console.log(result); // 8
    
    // You can use the result directly
    console.log(add(10, 20)); // 30
    
    // Once return executes, the function stops
    function checkAge(age) {
        if (age >= 18) {
            return 'Adult';
        }
        return 'Minor'; // This only runs if age < 18
    }</code></pre>
    
                <h3>Parameters vs Arguments: The Difference</h3>
                <pre><code>// Parameters are the placeholders in the function definition
    function multiply(x, y) {  // x and y are parameters
        return x * y;
    }
    
    // Arguments are the actual values passed when calling
    multiply(5, 3);  // 5 and 3 are arguments</code></pre>
    
                <h3>Default Parameters: Providing Fallback Values</h3>
                <pre><code>function greet(name = 'Guest') {
        console.log(`Hello, ${name}!`);
    }
    
    greet('Alice');  // Hello, Alice!
    greet();         // Hello, Guest! (uses default)</code></pre>
    
                <h3>Function Expressions: Functions as Values</h3>
                <p>Functions can be stored in variables:</p>
    
                <pre><code>const subtract = function(a, b) {
        return a - b;
    };
    
    console.log(subtract(10, 4)); // 6</code></pre>
    
                <h3>Arrow Functions: Modern Syntax</h3>
                <p>Arrow functions provide a shorter syntax:</p>
    
                <pre><code>// Traditional function
    function square(x) {
        return x * x;
    }
    
    // Arrow function
    const square = (x) => {
        return x * x;
    };
    
    // Shorter arrow function (implicit return)
    const square = x => x * x;
    
    // Multiple parameters need parentheses
    const add = (a, b) => a + b;
    
    // No parameters need empty parentheses
    const sayHi = () => console.log('Hi!');</code></pre>
    
                <div class="tip-box">
                    <strong>When to use arrow functions:</strong> Use them for short, simple functions and callbacks.
                    They're more concise and handle the <code>this</code> keyword differently (we'll cover that later). Use
                    traditional functions for methods and when you need the arguments object.
                </div>
    
                <h3>Common Function Mistakes</h3>
    
                <pre><code>// Mistake 1: Forgetting to call the function
    function sayHello() {
        console.log('Hello!');
    }
    
    sayHello;   // ✗ Wrong - just references the function
    sayHello(); // ✓ Right - actually calls it
    
    // Mistake 2: Returning nothing
    function calculate(x) {
        x * 2; // ✗ Doesn't return anything
    }
    console.log(calculate(5)); // undefined
    
    function calculate(x) {
        return x * 2; // ✓ Returns the result
    }
    console.log(calculate(5)); // 10
    
    // Mistake 3: Using variables before they're defined
    doSomething(); // ✗ Error with const/let
    
    const doSomething = () => {
        console.log('Done!');
    };</code></pre>
    
                <h2>JavaScript Conditional Statements</h2>
    
                <p>Conditional statements let your code make decisions. They're like forks in the road—your code goes one
                    way or another based on whether a condition is true or false.</p>
    
                <h3>If Statements: The Basic Decision</h3>
                <pre><code>let temperature = 25;
    
    if (temperature > 30) {
        console.log("It's hot outside!");
    }
    
    // Nothing happens because temperature is not > 30</code></pre>
    
                <h3>If-Else: Two Paths</h3>
                <pre><code>let age = 16;
    
    if (age >= 18) {
        console.log('You can vote!');
    } else {
        console.log('Too young to vote.');
    }
    
    // Output: Too young to vote.</code></pre>
    
                <h3>Else-If: Multiple Conditions</h3>
                <pre><code>let score = 75;
    
    if (score >= 90) {
        console.log('Grade: A');
    } else if (score >= 80) {
        console.log('Grade: B');
    } else if (score >= 70) {
        console.log('Grade: C');
    } else if (score >= 60) {
        console.log('Grade: D');
    } else {
        console.log('Grade: F');
    }
    
    // Output: Grade: C</code></pre>
    
                <h3>Switch Statements: Multiple Equal Comparisons</h3>
                <p>When checking one value against many possibilities, switch is cleaner than multiple if-else:</p>
    
                <pre><code>let day = 'Monday';
    
    switch (day) {
        case 'Monday':
            console.log('Start of work week');
            break;
        case 'Friday':
            console.log('Almost weekend!');
            break;
        case 'Saturday':
        case 'Sunday':
            console.log('Weekend!');
            break;
        default:
            console.log('Midweek day');
    }
    
    // Output: Start of work week</code></pre>
    
                <div class="warning-box">
                    <strong>Critical:</strong> Don't forget <code>break</code> in switch statements! Without it, execution
                    "falls through" to the next case. This is rarely what you want.
                </div>
    
                <h3>Ternary Operator: Compact Conditional</h3>
                <p>For simple if-else statements, the ternary operator is more concise:</p>
    
                <pre><code>// Regular if-else
    let age = 20;
    let status;
    if (age >= 18) {
        status = 'adult';
    } else {
        status = 'minor';
    }
    
    // Ternary operator (condition ? ifTrue : ifFalse)
    let status = age >= 18 ? 'adult' : 'minor';
    
    // Useful for conditional assignment
    let greeting = isLoggedIn ? 'Welcome back!' : 'Please log in';</code></pre>
    
                <h3>Truthy and Falsy Values</h3>
                <p>JavaScript converts values to boolean in conditionals. These values are "falsy" (treated as false):</p>
    
                <pre><code>// Falsy values
    false
    0
    '' (empty string)
    null
    undefined
    NaN (Not a Number)
    
    // Everything else is "truthy"
    if ('hello') {    // true (non-empty string)
    if (42) {         // true (non-zero number)
    if ([]) {         // true (even empty arrays!)
    if ({}) {         // true (even empty objects!)</code></pre>
    
                <h2>JavaScript Loops Explained</h2>
    
                <p>Loops let you run the same code multiple times without writing it repeatedly. Think of them as automated
                    repetition—like telling someone "do this 10 times" instead of writing out each instruction.</p>
    
                <h3>For Loop: Counting to a Number</h3>
                <p>The for loop is perfect when you know how many times to repeat:</p>
    
                <pre><code>// Count from 0 to 4
    for (let i = 0; i < 5; i++) {
        console.log(i);
    }
    // Output: 0, 1, 2, 3, 4
    
    // Breaking it down:
    // let i = 0     - Start: create variable i at 0
    // i < 5         - Condition: keep going while i < 5
    // i++           - Update: increase i by 1 each time</code></pre>
    
                <p>Real-world example:</p>
    
                <pre><code>// Create a multiplication table
    for (let i = 1; i <= 10; i++) {
        console.log(`5 x ${i} = ${5 * i}`);
    }
    
    // Output:
    // 5 x 1 = 5
    // 5 x 2 = 10
    // ... and so on</code></pre>
    
                <h3>While Loop: Repeat While Condition Is True</h3>
                <pre><code>let count = 0;
    
    while (count < 5) {
        console.log(count);
        count++;
    }
    // Output: 0, 1, 2, 3, 4
    
    // Real example: Keep asking until valid input
    let password = '';
    while (password !== 'secret') {
        password = prompt('Enter password:');
    }
    console.log('Access granted!');</code></pre>
    
                <div class="warning-box">
                    <strong>Infinite Loop Danger:</strong> Make sure your loop condition eventually becomes false! If not,
                    your code will run forever and crash the browser.
                    <pre><code>// ✗ DANGER - Never do this!
    while (true) {
        console.log('This never stops!');
    }</code></pre>
                </div>
    
                <h3>Do-While Loop: Runs At Least Once</h3>
                <pre><code>let number = 10;
    
    do {
        console.log(number);
        number++;
    } while (number < 5);
    
    // Output: 10
    // Even though condition is false, it runs once</code></pre>
    
                <h3>Breaking and Continuing Loops</h3>
                <pre><code>// break - exit the loop immediately
    for (let i = 0; i < 10; i++) {
        if (i === 5) {
            break; // Stop when i reaches 5
        }
        console.log(i);
    }
    // Output: 0, 1, 2, 3, 4
    
    // continue - skip to next iteration
    for (let i = 0; i < 5; i++) {
        if (i === 2) {
            continue; // Skip 2
        }
        console.log(i);
    }
    // Output: 0, 1, 3, 4</code></pre>
    
                <h3>For...Of Loop: Modern Array Iteration</h3>
                <pre><code>let fruits = ['apple', 'banana', 'cherry'];
    
    for (let fruit of fruits) {
        console.log(fruit);
    }
    // Output:
    // apple
    // banana
    // cherry</code></pre>
    
                <h2>JavaScript Events and Event Listeners</h2>
    
                <p>Events are things that happen in the browser—clicks, key presses, mouse movements, page loads. Event
                    listeners are like security guards that watch for specific events and take action when they occur.</p>
    
                <h3>Understanding the Event System</h3>
                <p>Think of events as notifications. When something happens (a user clicks a button), the browser sends a
                    notification. Your event listener is "listening" for that specific notification and responds
                    accordingly.</p>
    
                <h3>Adding Event Listeners: The Right Way</h3>
                <pre><code>// HTML
    &lt;button id="myButton"&gt;Click Me&lt;/button&gt;
    
    // JavaScript
    const button = document.getElementById('myButton');
    
    button.addEventListener('click', function() {
        console.log('Button was clicked!');
    });
    
    // With arrow function (more modern)
    button.addEventListener('click', () => {
        console.log('Button was clicked!');
    });</code></pre>
    
                <h3>Common Events You'll Use</h3>
                <pre><code>// Click events
    element.addEventListener('click', () => {
        // Runs when element is clicked
    });
    
    // Mouse events
    element.addEventListener('mouseenter', () => {
        // Runs when mouse enters element
    });
    
    element.addEventListener('mouseleave', () => {
        // Runs when mouse leaves element
    });
    
    // Keyboard events
    document.addEventListener('keydown', (event) => {
        console.log(`Key pressed: ${event.key}`);
    });
    
    // Form events
    input.addEventListener('input', (event) => {
        console.log(`Current value: ${event.target.value}`);
    });
    
    form.addEventListener('submit', (event) => {
        event.preventDefault(); // Prevent form from submitting
        // Handle form data here
    });
    
    // Page events
    window.addEventListener('load', () => {
        console.log('Page fully loaded!');
    });
    
    window.addEventListener('scroll', () => {
        console.log('User is scrolling');
    });</code></pre>
    
                <h3>The Event Object: Information About What Happened</h3>
                <p>Event listeners receive an event object with details about what happened:</p>
    
                <pre><code>button.addEventListener('click', (event) => {
        console.log(event.type);        // "click"
        console.log(event.target);      // The button element
        console.log(event.clientX);     // Mouse X position
        console.log(event.clientY);     // Mouse Y position
    });
    
    input.addEventListener('keydown', (event) => {
        console.log(event.key);         // Which key was pressed
        console.log(event.code);        // Key code
        
        if (event.key === 'Enter') {
            console.log('Enter key pressed!');
        }
    });</code></pre>
    
                <h3>Preventing Default Behavior</h3>
                <pre><code>// Prevent link from navigating
    link.addEventListener('click', (event) => {
        event.preventDefault();
        console.log('Link clicked but not navigating');
    });
    
    // Prevent form submission
    form.addEventListener('submit', (event) => {
        event.preventDefault();
        // Validate and handle form data
        console.log('Form submitted but not refreshing page');
    });</code></pre>
    
                <h3>Removing Event Listeners</h3>
                <p>Sometimes you need to stop listening for events:</p>
    
                <pre><code>function handleClick() {
        console.log('Clicked!');
    }
    
    // Add listener
    button.addEventListener('click', handleClick);
    
    // Remove listener (must use same function reference)
    button.removeEventListener('click', handleClick);
    
    // ✗ This won't work (different function references)
    button.addEventListener('click', () => console.log('Hi'));
    button.removeEventListener('click', () => console.log('Hi')); // Different function!</code></pre>
    
                <h3>Event Delegation: Efficient Event Handling</h3>
                <p>Instead of adding listeners to many elements, add one to their parent:</p>
    
                <pre><code>// Bad: Adding listener to each button
    document.querySelectorAll('.button').forEach(btn => {
        btn.addEventListener('click', handleClick);
    });
    
    // Good: One listener on parent
    document.querySelector('.button-container').addEventListener('click', (event) => {
        if (event.target.classList.contains('button')) {
            handleClick(event);
        }
    });</code></pre>
    
                <h2>DOM Manipulation Basics</h2>
    
                <p>The DOM (Document Object Model) is JavaScript's representation of your HTML page. Think of it as a live,
                    interactive map of your webpage that JavaScript can read and modify. When you manipulate the DOM, you're
                    changing what users see in real-time.</p>
    
                <h3>Selecting Elements: Finding What to Change</h3>
                <pre><code>// Select by ID
    const header = document.getElementById('header');
    
    // Select by class (returns first match)
    const button = document.querySelector('.btn');
    
    // Select all matching elements
    const allButtons = document.querySelectorAll('.btn');
    
    // Select by tag name
    const paragraphs = document.getElementsByTagName('p');
    
    // Modern approach: querySelector for everything
    const firstParagraph = document.querySelector('p');
    const allLinks = document.querySelectorAll('a');</code></pre>
    
                <div class="tip-box">
                    <strong>Best Practice:</strong> Use <code>querySelector</code> and <code>querySelectorAll</code> for
                    everything. They use CSS selectors you already know and work consistently across all scenarios.
                </div>
    
                <h3>Changing Content: Text and HTML</h3>
                <pre><code>const element = document.querySelector('.message');
    
    // Change text content (safe, escapes HTML)
    element.textContent = 'Hello, World!';
    
    // Change HTML (use carefully, can be security risk)
    element.innerHTML = '&lt;strong&gt;Hello&lt;/strong&gt;, World!';
    
    // Get current content
    console.log(element.textContent);</code></pre>
    
                <div class="warning-box">
                    <strong>Security Warning:</strong> Never use <code>innerHTML</code> with user input! It can execute
                    malicious scripts. Always use <code>textContent</code> for user-generated content.
                </div>
    
                <h3>Changing Styles: CSS from JavaScript</h3>
                <pre><code>const box = document.querySelector('.box');
    
    // Change individual style properties
    box.style.backgroundColor = 'blue';
    box.style.fontSize = '20px';
    box.style.padding = '10px';
    
    // Note: CSS properties become camelCase
    // background-color → backgroundColor
    // font-size → fontSize
    
    // Better approach: Toggle classes
    box.classList.add('highlighted');
    box.classList.remove('hidden');
    box.classList.toggle('active'); // Add if absent, remove if present
    
    // Check if class exists
    if (box.classList.contains('active')) {
        console.log('Box is active!');
    }</code></pre>
    
                <h3>Changing Attributes</h3>
                <pre><code>const link = document.querySelector('a');
    
    // Get attribute
    console.log(link.getAttribute('href'));
    
    // Set attribute
    link.setAttribute('href', 'https://example.com');
    link.setAttribute('target', '_blank');
    
    // Remove attribute
    link.removeAttribute('target');
    
    // Check if attribute exists
    if (link.hasAttribute('download')) {
        console.log('This is a download link');
    }</code></pre>
    
                <h3>Creating and Adding Elements</h3>
                <pre><code>// Create a new element
    const newParagraph = document.createElement('p');
    newParagraph.textContent = 'This is a new paragraph';
    newParagraph.classList.add('highlight');
    
    // Add it to the page
    const container = document.querySelector('.container');
    container.appendChild(newParagraph); // Add as last child
    
    // Insert at specific position
    container.insertBefore(newParagraph, container.firstChild); // Add as first child
    
    // Modern approach
    container.append(newParagraph);          // Add at end
    container.prepend(newParagraph);         // Add at beginning
    container.before(newParagraph);          // Add before container
    container.after(newParagraph);           // Add after container</code></pre>
    
                <h3>Removing Elements</h3>
                <pre><code>const element = document.querySelector('.old-element');
    
    // Remove the element
    element.remove();
    
    // Old way (still works)
    element.parentElement.removeChild(element);</code></pre>
    
                <h3>Practical Example: Interactive Counter</h3>
                <pre><code>// HTML:
    // &lt;div id="counter"&gt;0&lt;/div&gt;
    // &lt;button id="increment"&gt;+&lt;/button&gt;
    // &lt;button id="decrement"&gt;-&lt;/button&gt;
    // &lt;button id="reset"&gt;Reset&lt;/button&gt;
    
    let count = 0;
    const counterDisplay = document.getElementById('counter');
    const incrementBtn = document.getElementById('increment');
    const decrementBtn = document.getElementById('decrement');
    const resetBtn = document.getElementById('reset');
    
    incrementBtn.addEventListener('click', () => {
        count++;
        counterDisplay.textContent = count;
    });
    
    decrementBtn.addEventListener('click', () => {
        count--;
        counterDisplay.textContent = count;
    });
    
    resetBtn.addEventListener('click', () => {
        count = 0;
        counterDisplay.textContent = count;
    });</code></pre>
    
                <span class="section-label intermediate">INTERMEDIATE</span>
                <h2>JavaScript Arrays and Objects</h2>
    
                <p>Arrays and objects are the workhorses of JavaScript. Arrays store ordered lists of values, while objects
                    store related data as key-value pairs. Master these, and you unlock JavaScript's real power.</p>
    
                <h3>Arrays: Ordered Collections</h3>
                <pre><code>// Creating arrays
    const fruits = ['apple', 'banana', 'cherry'];
    const numbers = [1, 2, 3, 4, 5];
    const mixed = ['text', 42, true, null]; // Can mix types
    
    // Accessing elements (zero-indexed)
    console.log(fruits[0]);  // 'apple'
    console.log(fruits[1]);  // 'banana'
    console.log(fruits[2]);  // 'cherry'
    
    // Array length
    console.log(fruits.length); // 3
    
    // Last element
    console.log(fruits[fruits.length - 1]); // 'cherry'</code></pre>
    
                <h3>Essential Array Methods</h3>
                <pre><code>let numbers = [1, 2, 3];
    
    // Add to end
    numbers.push(4);           // [1, 2, 3, 4]
    
    // Remove from end
    numbers.pop();             // [1, 2, 3] - returns 3
    
    // Add to beginning
    numbers.unshift(0);        // [0, 1, 2, 3]
    
    // Remove from beginning
    numbers.shift();           // [1, 2, 3] - returns 0
    
    // Find index of element
    numbers.indexOf(2);        // 1
    
    // Check if element exists
    numbers.includes(2);       // true
    
    // Remove/add elements at position
    numbers.splice(1, 1);      // Remove 1 element at index 1
    numbers.splice(1, 0, 5);   // Add 5 at index 1</code></pre>
    
                <h3>Modern Array Methods: The Power Tools</h3>
                <pre><code>const numbers = [1, 2, 3, 4, 5];
    
    // map - transform each element
    const doubled = numbers.map(num => num * 2);
    // [2, 4, 6, 8, 10]
    
    // filter - keep elements that pass test
    const evens = numbers.filter(num => num % 2 === 0);
    // [2, 4]
    
    // find - get first element that passes test
    const firstEven = numbers.find(num => num % 2 === 0);
    // 2
    
    // reduce - combine all elements into one value
    const sum = numbers.reduce((total, num) => total + num, 0);
    // 15
    
    // forEach - run function for each element
    numbers.forEach(num => {
        console.log(num * 2);
    });
    
    // some - check if ANY element passes test
    const hasEven = numbers.some(num => num % 2 === 0);
    // true
    
    // every - check if ALL elements pass test
    const allPositive = numbers.every(num => num > 0);
    // true</code></pre>
    
                <h3>Objects: Key-Value Stores</h3>
                <pre><code>// Creating objects
    const person = {
        firstName: 'John',
        lastName: 'Doe',
        age: 30,
        isEmployed: true,
        hobbies: ['reading', 'coding']
    };
    
    // Accessing properties
    console.log(person.firstName);        // Dot notation
    console.log(person['lastName']);      // Bracket notation
    
    // Adding/modifying properties
    person.email = 'john@example.com';    // Add new property
    person.age = 31;                      // Modify existing
    
    // Deleting properties
    delete person.isEmployed;
    
    // Check if property exists
    console.log('email' in person);       // true
    console.log(person.hasOwnProperty('age')); // true</code></pre>
    
                <h3>Object Methods: Functions Inside Objects</h3>
                <pre><code>const calculator = {
        value: 0,
        
        add: function(num) {
            this.value += num;
            return this;
        },
        
        subtract: function(num) {
            this.value -= num;
            return this;
        },
        
        // Modern shorthand
        multiply(num) {
            this.value *= num;
            return this;
        },
        
        getResult() {
            return this.value;
        }
    };
    
    // Using methods
    calculator.add(10).multiply(2).subtract(5);
    console.log(calculator.getResult()); // 15</code></pre>
    
                <h3>Destructuring: Unpacking Values</h3>
                <pre><code>// Array destructuring
    const [first, second, third] = ['apple', 'banana', 'cherry'];
    console.log(first);  // 'apple'
    console.log(second); // 'banana'
    
    // Skip elements
    const [a, , c] = [1, 2, 3];
    console.log(a, c); // 1, 3
    
    // Object destructuring
    const person = { name: 'Alice', age: 25, city: 'NYC' };
    const { name, age } = person;
    console.log(name); // 'Alice'
    console.log(age);  // 25
    
    // Rename while destructuring
    const { name: personName } = person;
    console.log(personName); // 'Alice'</code></pre>
    
                <h3>Spread Operator: Copying and Combining</h3>
                <pre><code>// Copy array
    const original = [1, 2, 3];
    const copy = [...original];
    
    // Combine arrays
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    const combined = [...arr1, ...arr2]; // [1, 2, 3, 4]
    
    // Copy object
    const person = { name: 'John', age: 30 };
    const personCopy = { ...person };
    
    // Combine objects
    const details = { city: 'NYC', country: 'USA' };
    const fullPerson = { ...person, ...details };
    // { name: 'John', age: 30, city: 'NYC', country: 'USA' }</code></pre>
    
                <h2>JavaScript Scope and Closures</h2>
    
                <p>Scope determines where variables are accessible in your code. Understanding scope prevents bugs and helps
                    you write cleaner code. Closures are one of JavaScript's most powerful features—they let functions
                    "remember" variables even after the outer function has finished.</p>
    
                <h3>Global vs Local Scope</h3>
                <pre><code>// Global scope - accessible everywhere
    const globalVar = 'I am global';
    
    function myFunction() {
        // Local scope - only accessible inside this function
        const localVar = 'I am local';
        console.log(globalVar);  // ✓ Can access global
        console.log(localVar);   // ✓ Can access local
    }
    
    myFunction();
    console.log(globalVar);      // ✓ Can access global
    console.log(localVar);       // ✗ Error! localVar is not defined</code></pre>
    
                <h3>Block Scope with let and const</h3>
                <pre><code>if (true) {
        const blockScoped = 'I only exist in this block';
        let alsoBlockScoped = 'Me too';
    }
    
    console.log(blockScoped); // ✗ Error! Not accessible outside block
    
    // var doesn't respect block scope (another reason to avoid it)
    if (true) {
        var notBlockScoped = 'I leak out';
    }
    console.log(notBlockScoped); // ✓ Works (but shouldn't!)</code></pre>
    
                <h3>Closures: Functions That Remember</h3>
                <p>A closure is created when an inner function accesses variables from an outer function:</p>
    
                <pre><code>function createCounter() {
        let count = 0; // This variable is "closed over"
        
        return function() {
            count++;
            return count;
        };
    }
    
    const counter = createCounter();
    console.log(counter()); // 1
    console.log(counter()); // 2
    console.log(counter()); // 3
    
    // count is private - can't access it directly
    console.log(count); // ✗ Error! count is not defined</code></pre>
    
                <p>The inner function "remembers" the <code>count</code> variable even after <code>createCounter</code> has
                    finished executing. This is incredibly useful for data privacy and creating function factories.</p>
    
                <h3>Practical Closure Example: Private Variables</h3>
                <pre><code>function bankAccount(initialBalance) {
        let balance = initialBalance; // Private variable
        
        return {
            deposit(amount) {
                balance += amount;
                return balance;
            },
            
            withdraw(amount) {
                if (amount > balance) {
                    return 'Insufficient funds';
                }
                balance -= amount;
                return balance;
            },
            
            getBalance() {
                return balance;
            }
        };
    }
    
    const myAccount = bankAccount(100);
    console.log(myAccount.getBalance());  // 100
    myAccount.deposit(50);                // 150
    myAccount.withdraw(30);               // 120
    console.log(myAccount.balance);       // undefined (private!)</code></pre>
    
                <h2>JavaScript Error Handling</h2>
    
                <p>Errors are inevitable in programming. Good error handling makes your code resilient and helps you debug
                    issues quickly. Instead of letting errors crash your entire application, you can catch and handle them
                    gracefully.</p>
    
                <h3>Try-Catch: Handling Errors</h3>
                <pre><code>try {
        // Code that might throw an error
        const result = riskyOperation();
        console.log(result);
    } catch (error) {
        // Runs if an error occurs
        console.log('An error occurred:', error.message);
    } finally {
        // Always runs, error or not
        console.log('Cleanup code here');
    }</code></pre>
    
                <h3>Real-World Example: Parsing JSON</h3>
                <pre><code>function parseUserData(jsonString) {
        try {
            const data = JSON.parse(jsonString);
            return data;
        } catch (error) {
            console.error('Invalid JSON:', error.message);
            return null;
        }
    }
    
    // Valid JSON
    const user = parseUserData('{"name":"John","age":30}');
    console.log(user); // { name: 'John', age: 30 }
    
    // Invalid JSON
    const badData = parseUserData('not valid json');
    console.log(badData); // null (handled gracefully)</code></pre>
    
                <h3>Throwing Custom Errors</h3>
                <pre><code>function divide(a, b) {
        if (b === 0) {
            throw new Error('Cannot divide by zero!');
        }
        return a / b;
    }
    
    try {
        const result = divide(10, 0);
    } catch (error) {
        console.log(error.message); // 'Cannot divide by zero!'
    }</code></pre>
    
                <h3>Custom Error Types</h3>
                <pre><code>class ValidationError extends Error {
        constructor(message) {
            super(message);
            this.name = 'ValidationError';
        }
    }
    
    function validateAge(age) {
        if (age < 0) {
            throw new ValidationError('Age cannot be negative');
        }
        if (age > 150) {
            throw new ValidationError('Age seems unrealistic');
        }
        return true;
    }
    
    try {
        validateAge(-5);
    } catch (error) {
        if (error instanceof ValidationError) {
            console.log('Validation failed:', error.message);
        } else {
            console.log('Unknown error:', error);
        }
    }</code></pre>
    
                <h2>JavaScript Form Validation</h2>
    
                <p>Form validation ensures users enter correct data before submission. Client-side validation provides
                    instant feedback, but always validate on the server too—users can bypass JavaScript.</p>
    
                <h3>Basic Form Validation Example</h3>
                <pre><code>// HTML:
    // &lt;form id="registrationForm"&gt;
    //   &lt;input type="text" id="username" placeholder="Username"&gt;
    //   &lt;input type="email" id="email" placeholder="Email"&gt;
    //   &lt;input type="password" id="password" placeholder="Password"&gt;
    //   &lt;button type="submit"&gt;Register&lt;/button&gt;
    //   &lt;div id="errors"&gt;&lt;/div&gt;
    // &lt;/form&gt;
    
    const form = document.getElementById('registrationForm');
    const errorsDiv = document.getElementById('errors');
    
    form.addEventListener('submit', (event) => {
        event.preventDefault(); // Stop form from submitting
        
        const errors = [];
        const username = document.getElementById('username').value.trim();
        const email = document.getElementById('email').value.trim();
        const password = document.getElementById('password').value;
        
        // Username validation
        if (username.length < 3) {
            errors.push('Username must be at least 3 characters');
        }
        
        // Email validation
        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailPattern.test(email)) {
            errors.push('Please enter a valid email');
        }
        
        // Password validation
        if (password.length < 8) {
            errors.push('Password must be at least 8 characters');
        }
        
        // Display errors or submit
        if (errors.length > 0) {
            errorsDiv.innerHTML = errors.map(err => `&lt;p&gt;${err}&lt;/p&gt;`).join('');
        } else {
            errorsDiv.innerHTML = '&lt;p&gt;Form is valid! Submitting...&lt;/p&gt;';
            // Actually submit the form here
        }
    });</code></pre>
    
                <h3>Real-Time Validation</h3>
                <pre><code>const emailInput = document.getElementById('email');
    const emailError = document.getElementById('emailError');
    
    emailInput.addEventListener('input', () => {
        const email = emailInput.value.trim();
        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        
        if (email === '') {
            emailError.textContent = '';
        } else if (!emailPattern.test(email)) {
            emailError.textContent = 'Invalid email format';
            emailInput.classList.add('invalid');
        } else {
            emailError.textContent = '✓ Valid email';
            emailInput.classList.remove('invalid');
            emailInput.classList.add('valid');
        }
    });</code></pre>
    
                <h2>JavaScript Fetch API</h2>
    
                <p>The Fetch API lets JavaScript communicate with servers without reloading the page. It's how modern web
                    apps get data, send form submissions, and interact with APIs. Think of it as JavaScript's way of making
                    phone calls to other servers.</p>
    
                <h3>Basic GET Request</h3>
                <pre><code>// Fetch data from an API
    fetch('https://api.example.com/users')
        .then(response => response.json())
        .then(data => {
            console.log(data);
        })
        .catch(error => {
            console.error('Error:', error);
        });</code></pre>
    
                <h3>Fetch with Async/Await (Modern Approach)</h3>
                <pre><code>async function getUsers() {
        try {
            const response = await fetch('https://api.example.com/users');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log(data);
            return data;
        } catch (error) {
            console.error('Failed to fetch users:', error);
        }
    }</code></pre>
    
                <h3>POST Request: Sending Data</h3>
                <pre><code>async function createUser(userData) {
        try {
            const response = await fetch('https://api.example.com/users', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(userData)
            });
            
            const data = await response.json();
            console.log('User created:', data);
            return data;
        } catch (error) {
            console.error('Error creating user:', error);
        }
    }
    
    // Usage
    createUser({
        name: 'John Doe',
        email: 'john@example.com'
    });</code></pre>
    
                <h3>Practical Example: Loading Posts</h3>
                <pre><code>async function loadPosts() {
        const container = document.getElementById('posts');
        container.innerHTML = '&lt;p&gt;Loading...&lt;/p&gt;';
        
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/posts');
            const posts = await response.json();
            
            container.innerHTML = posts.slice(0, 5).map(post => `
                &lt;div class="post"&gt;
                    &lt;h3&gt;${post.title}&lt;/h3&gt;
                    &lt;p&gt;${post.body}&lt;/p&gt;
                &lt;/div&gt;
            `).join('');
            
        } catch (error) {
            container.innerHTML = '&lt;p&gt;Failed to load posts&lt;/p&gt;';
        }
    }</code></pre>
    
                <h2>JavaScript Local Storage and Session Storage</h2>
    
                <p>Web Storage APIs let you save data in the browser. LocalStorage persists even after closing the browser,
                    while SessionStorage clears when the tab closes. Think of LocalStorage as a filing cabinet and
                    SessionStorage as a notepad that gets thrown away at day's end.</p>
    
                <h3>LocalStorage: Permanent Browser Storage</h3>
                <pre><code>// Save data
    localStorage.setItem('username', 'JohnDoe');
    localStorage.setItem('theme', 'dark');
    
    // Retrieve data
    const username = localStorage.getItem('username');
    console.log(username); // 'JohnDoe'
    
    // Remove specific item
    localStorage.removeItem('theme');
    
    // Clear everything
    localStorage.clear();
    
    // Check if item exists
    if (localStorage.getItem('username')) {
        console.log('User is remembered');
    }</code></pre>
    
                <h3>Storing Objects: JSON Conversion</h3>
                <pre><code>const user = {
        name: 'Alice',
        age: 25,
        preferences: { theme: 'dark', language: 'en' }
    };
    
    // Save object (convert to JSON string)
    localStorage.setItem('user', JSON.stringify(user));
    
    // Retrieve and parse
    const savedUser = JSON.parse(localStorage.getItem('user'));
    console.log(savedUser.name); // 'Alice'</code></pre>
    
                <h3>Practical Example: Remember Theme Preference</h3>
                <pre><code>// On page load
    document.addEventListener('DOMContentLoaded', () => {
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.body.className = savedTheme;
    });
    
    // Theme toggle button
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('click', () => {
        const currentTheme = document.body.className;
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        
        document.body.className = newTheme;
        localStorage.setItem('theme', newTheme);
    });</code></pre>
    
                <h3>SessionStorage: Temporary Storage</h3>
                <pre><code>// Identical API to localStorage, but clears on tab close
    sessionStorage.setItem('tempData', 'value');
    const data = sessionStorage.getItem('tempData');
    sessionStorage.removeItem('tempData');
    sessionStorage.clear();</code></pre>
    
                <div class="warning-box">
                    <strong>Storage Limits:</strong> LocalStorage and SessionStorage typically limit you to 5-10MB. Don't
                    store sensitive data like passwords—storage is not encrypted and accessible via JavaScript.
                </div>
    
                <h2>JavaScript ES6 Features Explained</h2>
    
                <p>ES6 (ECMAScript 2015) modernized JavaScript with features that make code cleaner and more powerful. These
                    aren't optional extras—they're now standard in modern JavaScript development.</p>
    
                <h3>Let and Const: Block-Scoped Variables</h3>
                <pre><code>// Old: var (function-scoped, hoisted)
    var x = 10;
    
    // Modern: let (block-scoped, can reassign)
    let y = 20;
    y = 30; // ✓ Works
    
    // Modern: const (block-scoped, cannot reassign)
    const z = 40;
    z = 50; // ✗ Error!
    
    // const with objects (can modify properties)
    const person = { name: 'John' };
    person.name = 'Jane'; // ✓ Works (modifying property)
    person = {};          // ✗ Error! (reassigning variable)</code></pre>
    
                <h3>Template Literals: String Interpolation</h3>
                <pre><code>const name = 'Alice';
    const age = 25;
    
    // Old way
    const message1 = 'Hello, ' + name + '. You are ' + age + ' years old.';
    
    // ES6 way
    const message2 = `Hello, ${name}. You are ${age} years old.`;
    
    // Multi-line strings
    const html = `
        &lt;div&gt;
            &lt;h2&gt;${name}&lt;/h2&gt;
            &lt;p&gt;Age: ${age}&lt;/p&gt;
        &lt;/div&gt;
    `;</code></pre>
    
                <h3>Arrow Functions: Concise Syntax</h3>
                <pre><code>// Traditional function
    function add(a, b) {
        return a + b;
    }
    
    // Arrow function
    const add = (a, b) => a + b;
    
    // With multiple statements
    const calculate = (a, b) => {
        const sum = a + b;
        return sum * 2;
    };
    
    // Single parameter (parentheses optional)
    const square = x => x * x;</code></pre>
    
                <h3>Destructuring: Unpacking Values</h3>
                <pre><code>// Array destructuring
    const [first, second] = ['apple', 'banana'];
    
    // Object destructuring
    const person = { name: 'John', age: 30, city: 'NYC' };
    const { name, age } = person;
    
    // Function parameter destructuring
    function greet({ name, age }) {
        console.log(`${name} is ${age} years old`);
    }
    greet(person);</code></pre>
    
                <h3>Spread and Rest Operators</h3>
                <pre><code>// Spread: Expand array
    const arr1 = [1, 2];
    const arr2 = [3, 4];
    const combined = [...arr1, ...arr2]; // [1, 2, 3, 4]
    
    // Spread: Copy object
    const original = { a: 1, b: 2 };
    const copy = { ...original, c: 3 }; // { a: 1, b: 2, c: 3 }
    
    // Rest: Collect remaining arguments
    function sum(...numbers) {
        return numbers.reduce((total, num) => total + num, 0);
    }
    sum(1, 2, 3, 4); // 10</code></pre>
    
                <h3>Default Parameters</h3>
                <pre><code>function greet(name = 'Guest', greeting = 'Hello') {
        console.log(`${greeting}, ${name}!`);
    }
    
    greet();                    // Hello, Guest!
    greet('Alice');             // Hello, Alice!
    greet('Bob', 'Hi');         // Hi, Bob!</code></pre>
    
                <span class="section-label advanced">ADVANCED</span>
                <h2>JavaScript Asynchronous Programming</h2>
    
                <p>Asynchronous programming lets JavaScript do multiple things at once without blocking. It's like ordering
                    food—you don't stand at the counter waiting; you get a number and do other things while your order is
                    prepared.</p>
    
                <h3>Callbacks: The Foundation</h3>
                <pre><code>// Simple callback
    function fetchData(callback) {
        setTimeout(() => {
            const data = { name: 'John', age: 30 };
            callback(data);
        }, 1000);
    }
    
    fetchData((data) => {
        console.log('Data received:', data);
    });
    
    // Problem: Callback hell
    fetchUser((user) => {
        fetchPosts(user.id, (posts) => {
            fetchComments(posts[0].id, (comments) => {
                // Nested callbacks become unreadable
            });
        });
    });</code></pre>
    
                <h3>Promises: Better Async Handling</h3>
                <pre><code>// Creating a promise
    function fetchData() {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                const success = true;
                
                if (success) {
                    resolve({ name: 'John', age: 30 });
                } else {
                    reject('Failed to fetch data');
                }
            }, 1000);
        });
    }
    
    // Using the promise
    fetchData()
        .then(data => {
            console.log('Success:', data);
            return data.age;
        })
        .then(age => {
            console.log('Age:', age);
        })
        .catch(error => {
            console.error('Error:', error);
        })
        .finally(() => {
            console.log('Operation complete');
        });</code></pre>
    
                <h3>Async/Await: Modern Async Syntax</h3>
                <p>Async/await makes asynchronous code look and behave like synchronous code:</p>
    
                <pre><code>// Using promises (then/catch)
    function getUserData() {
        fetch('https://api.example.com/user')
            .then(response => response.json())
            .then(data => console.log(data))
            .catch(error => console.error(error));
    }
    
    // Using async/await (much cleaner!)
    async function getUserData() {
        try {
            const response = await fetch('https://api.example.com/user');
            const data = await response.json();
            console.log(data);
        } catch (error) {
            console.error(error);
        }
    }</code></pre>
    
                <h3>Multiple Async Operations</h3>
                <pre><code>// Sequential (one after another)
    async function sequential() {
        const user = await fetchUser();        // Wait 1 second
        const posts = await fetchPosts();      // Wait another 1 second
        // Total: 2 seconds
    }
    
    // Parallel (at the same time)
    async function parallel() {
        const [user, posts] = await Promise.all([
            fetchUser(),
            fetchPosts()
        ]);
        // Total: 1 second (both run simultaneously)
    }
    
    // Race (use first one to finish)
    const fastest = await Promise.race([
        fetchFromServer1(),
        fetchFromServer2()
    ]);
    // Uses whichever responds first</code></pre>
    
                <h3>Real-World Example: Sequential API Calls</h3>
                <pre><code>async function loadUserDashboard(userId) {
        try {
            // Show loading indicator
            showLoading();
            
            // Fetch user data
            const user = await fetch(`/api/users/${userId}`).then(r => r.json());
            displayUser(user);
            
            // Fetch user's posts (needs user data first)
            const posts = await fetch(`/api/users/${userId}/posts`).then(r => r.json());
            displayPosts(posts);
            
            // Fetch comments in parallel with other data
            const [comments, likes] = await Promise.all([
                fetch(`/api/posts/${posts[0].id}/comments`).then(r => r.json()),
                fetch(`/api/users/${userId}/likes`).then(r => r.json())
            ]);
            
            displayComments(comments);
            displayLikes(likes);
            
        } catch (error) {
            showError('Failed to load dashboard');
            console.error(error);
        } finally {
            hideLoading();
        }
    }</code></pre>
    
                <h2>JavaScript Performance Optimization</h2>
    
                <p>Performance optimization ensures your JavaScript runs smoothly without slowing down the user's browser.
                    Slow code leads to frustrated users who abandon your site.</p>
    
                <h3>Debouncing: Limit Function Calls</h3>
                <p>Debouncing delays function execution until the user stops triggering the event:</p>
    
                <pre><code>// Without debouncing: runs on every keystroke (bad for search)
    searchInput.addEventListener('input', () => {
        searchAPI(searchInput.value); // Called 100 times for 10 characters!
    });
    
    // With debouncing: waits until user stops typing
    function debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }
    
    const debouncedSearch = debounce((value) => {
        searchAPI(value);
    }, 300);
    
    searchInput.addEventListener('input', (e) => {
        debouncedSearch(e.target.value);
    });</code></pre>
    
                <h3>Throttling: Limit Execution Frequency</h3>
                <p>Throttling ensures a function runs at most once per specified time period:</p>
    
                <pre><code>function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
    
    // Use for scroll events
    const handleScroll = throttle(() => {
        console.log('Scrolling...');
    }, 100);
    
    window.addEventListener('scroll', handleScroll);</code></pre>
    
                <h3>DOM Manipulation Optimization</h3>
                <pre><code>// Bad: Multiple DOM manipulations (causes reflows)
    for (let i = 0; i < 1000; i++) {
        const div = document.createElement('div');
        div.textContent = `Item ${i}`;
        document.body.appendChild(div); // Triggers reflow each time!
    }
    
    // Good: Build string, update once
    let html = '';
    for (let i = 0; i < 1000; i++) {
        html += `&lt;div&gt;Item ${i}&lt;/div&gt;`;
    }
    document.body.innerHTML = html; // Single reflow
    
    // Better: Document fragment
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < 1000; i++) {
        const div = document.createElement('div');
        div.textContent = `Item ${i}`;
        fragment.appendChild(div);
    }
    document.body.appendChild(fragment); // Single reflow</code></pre>
    
                <h3>Memory Leaks: Avoid These Patterns</h3>
                <pre><code>// Bad: Global variables never cleaned
    window.userData = [];
    function addUser(user) {
        window.userData.push(user); // Grows forever!
    }
    
    // Bad: Event listeners not removed
    function setupComponent() {
        const button = document.getElementById('btn');
        button.addEventListener('click', handleClick);
        // If component is removed but listener isn't, memory leaks!
    }
    
    // Good: Clean up
    function setupComponent() {
        const button = document.getElementById('btn');
        const handler = () => console.log('Clicked');
        
        button.addEventListener('click', handler);
        
        // Return cleanup function
        return () => {
            button.removeEventListener('click', handler);
        };
    }</code></pre>
    
                <h3>Lazy Loading: Load Only What's Needed</h3>
                <pre><code>// Load images only when visible
    const images = document.querySelectorAll('img[data-src]');
    
    const imageObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.src = img.dataset.src;
                img.removeAttribute('data-src');
                imageObserver.unobserve(img);
            }
        });
    });
    
    images.forEach(img => imageObserver.observe(img));</code></pre>
    
                <h2>JavaScript Security Best Practices</h2>
    
                <p>Security vulnerabilities can expose your users to attacks. Following these practices protects both your
                    users and your application.</p>
    
                <h3>XSS Prevention: Never Trust User Input</h3>
                <pre><code>// DANGEROUS: XSS vulnerability
    const userInput = '&lt;script&gt;alert("Hacked!")&lt;/script&gt;';
    element.innerHTML = userInput; // EXECUTES THE SCRIPT!
    
    // SAFE: Use textContent for user input
    element.textContent = userInput; // Shows the text, doesn't execute
    
    // SAFE: Sanitize if you must use innerHTML
    function sanitize(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }
    
    element.innerHTML = sanitize(userInput);</code></pre>
    
                <h3>Validating Input: Client and Server</h3>
                <pre><code>// Client-side validation (for UX)
    function validateEmail(email) {
        const pattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return pattern.test(email);
    }
    
    // ALWAYS validate on server too!
    // Users can bypass client-side JavaScript
    
    // Sanitize input before sending
    function prepareData(formData) {
        return {
            email: formData.email.trim().toLowerCase(),
            username: formData.username.trim().replace(/[<>]/g, ''),
            age: parseInt(formData.age, 10)
        };
    }</code></pre>
    
                <h3>Secure API Calls</h3>
                <pre><code>// Don't expose API keys in frontend code!
    // Bad:
    const API_KEY = 'sk_live_abc123'; // Visible to anyone!
    
    // Good: Use backend proxy
    async function getData() {
        // Your backend adds the API key
        const response = await fetch('/api/secure-endpoint');
        return response.json();
    }
    
    // Use HTTPS for sensitive data
    fetch('https://api.example.com/user', { // ✓ HTTPS
        credentials: 'include', // Send cookies securely
        headers: {
            'Content-Type': 'application/json'
        }
    });</code></pre>
    
                <h3>LocalStorage Security</h3>
                <pre><code>// Don't store sensitive data in localStorage!
    // Bad:
    localStorage.setItem('password', userPassword); // Accessible via JS!
    localStorage.setItem('creditCard', cardNumber); // Never!
    
    // Good: Store only non-sensitive data
    localStorage.setItem('theme', 'dark');
    localStorage.setItem('language', 'en');
    
    // For sensitive data: use httpOnly cookies (set by server)
    // JavaScript cannot access httpOnly cookies</code></pre>
    
                <h2>Building Small Projects with Vanilla JavaScript</h2>
    
                <p>The best way to learn JavaScript is by building real projects. Here's a complete todo app that combines
                    everything we've learned:</p>
    
                <h3>Complete Todo App</h3>
                <pre><code>// HTML:
    // &lt;div id="app"&gt;
    //   &lt;h1&gt;Todo List&lt;/h1&gt;
    //   &lt;input id="todoInput" placeholder="Add new todo"&gt;
    //   &lt;button id="addBtn"&gt;Add&lt;/button&gt;
    //   &lt;ul id="todoList"&gt;&lt;/ul&gt;
    // &lt;/div&gt;
    
    class TodoApp {
        constructor() {
            this.todos = this.loadTodos();
            this.input = document.getElementById('todoInput');
            this.addBtn = document.getElementById('addBtn');
            this.list = document.getElementById('todoList');
            
            this.init();
        }
        
        init() {
            // Render existing todos
            this.render();
            
            // Event listeners
            this.addBtn.addEventListener('click', () => this.addTodo());
            this.input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') this.addTodo();
            });
        }
        
        addTodo() {
            const text = this.input.value.trim();
            
            if (text === '') {
                alert('Please enter a todo');
                return;
            }
            
            const todo = {
                id: Date.now(),
                text: text,
                completed: false
            };
            
            this.todos.push(todo);
            this.input.value = '';
            this.saveTodos();
            this.render();
        }
        
        toggleTodo(id) {
            const todo = this.todos.find(t => t.id === id);
            if (todo) {
                todo.completed = !todo.completed;
                this.saveTodos();
                this.render();
            }
        }
        
        deleteTodo(id) {
            this.todos = this.todos.filter(t => t.id !== id);
            this.saveTodos();
            this.render();
        }
        
        saveTodos() {
            localStorage.setItem('todos', JSON.stringify(this.todos));
        }
        
        loadTodos() {
            const saved = localStorage.getItem('todos');
            return saved ? JSON.parse(saved) : [];
        }
        
        render() {
            this.list.innerHTML = this.todos.map(todo => `
                &lt;li class="${todo.completed ? 'completed' : ''}"&gt;
                    &lt;input 
                        type="checkbox" 
                        ${todo.completed ? 'checked' : ''}
                        onchange="app.toggleTodo(${todo.id})"
                    &gt;
                    &lt;span&gt;${todo.text}&lt;/span&gt;
                    &lt;button onclick="app.deleteTodo(${todo.id})"&gt;Delete&lt;/button&gt;
                &lt;/li&gt;
            `).join('');
        }
    }
    
    // Initialize app
    const app = new TodoApp();</code></pre>
    
                <h2>JavaScript Design Patterns</h2>
    
                <p>Design patterns are proven solutions to common programming problems. They make your code more organized,
                    maintainable, and scalable.</p>
    
                <h3>Module Pattern: Encapsulation</h3>
                <pre><code>const Calculator = (function() {
        // Private variables
        let result = 0;
        
        // Private function
        function log(operation, value) {
            console.log(`${operation}: ${value}`);
        }
        
        // Public API
        return {
            add(num) {
                result += num;
                log('Added', num);
                return this;
            },
            
            subtract(num) {
                result -= num;
                log('Subtracted', num);
                return this;
            },
            
            getResult() {
                return result;
            },
            
            reset() {
                result = 0;
                return this;
            }
        };
    })();
    
    Calculator.add(10).subtract(3);
    console.log(Calculator.getResult()); // 7</code></pre>
    
                <h3>Observer Pattern: Event System</h3>
                <pre><code>class EventEmitter {
        constructor() {
            this.events = {};
        }
        
        on(event, listener) {
            if (!this.events[event]) {
                this.events[event] = [];
            }
            this.events[event].push(listener);
        }
        
        emit(event, data) {
            if (this.events[event]) {
                this.events[event].forEach(listener => listener(data));
            }
        }
        
        off(event, listenerToRemove) {
            if (this.events[event]) {
                this.events[event] = this.events[event]
                    .filter(listener => listener !== listenerToRemove);
            }
        }
    }
    
    // Usage
    const emitter = new EventEmitter();
    
    emitter.on('user-login', (user) => {
        console.log(`Welcome, ${user.name}!`);
    });
    
    emitter.on('user-login', (user) => {
        console.log('Logging activity...');
    });
    
    emitter.emit('user-login', { name: 'Alice' });</code></pre>
    
                <h3>Singleton Pattern: Single Instance</h3>
                <pre><code>class Database {
        constructor() {
            if (Database.instance) {
                return Database.instance;
            }
            
            this.data = {};
            Database.instance = this;
        }
        
        set(key, value) {
            this.data[key] = value;
        }
        
        get(key) {
            return this.data[key];
        }
    }
    
    const db1 = new Database();
    const db2 = new Database();
    
    db1.set('user', 'John');
    console.log(db2.get('user')); // 'John' (same instance!)</code></pre>
    
                <h2>Common JavaScript Bugs and How to Fix Them</h2>
    
                <p>Even experienced developers make these mistakes. Knowing them helps you debug faster and write better
                    code.</p>
    
                <h3>Bug #1: Forgetting 'this' Context</h3>
                <pre><code>// Bug
    const person = {
        name: 'Alice',
        greet: function() {
            setTimeout(function() {
                console.log(`Hello, ${this.name}`); // this is undefined!
            }, 1000);
        }
    };
    
    // Fix 1: Arrow function (inherits this)
    const person = {
        name: 'Alice',
        greet: function() {
            setTimeout(() => {
                console.log(`Hello, ${this.name}`); // Works!
            }, 1000);
        }
    };
    
    // Fix 2: Save this reference
    const person = {
        name: 'Alice',
        greet: function() {
            const self = this;
            setTimeout(function() {
                console.log(`Hello, ${self.name}`); // Works!
            }, 1000);
        }
    };</code></pre>
    
                <h3>Bug #2: Asynchronous Loop Issues</h3>
                <pre><code>// Bug: All alerts show "5"
    for (var i = 0; i < 5; i++) {
        setTimeout(() => {
            console.log(i); // Always logs 5!
        }, 1000);
    }
    
    // Fix 1: Use let (block-scoped)
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            console.log(i); // Logs 0, 1, 2, 3, 4
        }, 1000);
    }
    
    // Fix 2: IIFE (creates closure)
    for (var i = 0; i < 5; i++) {
        (function(index) {
            setTimeout(() => {
                console.log(index);
            }, 1000);
        })(i);
    }</code></pre>
    
                <h3>Bug #3: Comparing Objects</h3>
                <pre><code>// Bug: Objects are compared by reference
    const obj1 = { name: 'John' };
    const obj2 = { name: 'John' };
    console.log(obj1 === obj2); // false! Different references
    
    // Fix: Compare properties
    function areEqual(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify(obj2);
    }
    
    // Better: Deep equality function
    function deepEqual(obj1, obj2) {
        if (obj1 === obj2) return true;
        if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;
        
        const keys1 = Object.keys(obj1);
        const keys2 = Object.keys(obj2);
        
        if (keys1.length !== keys2.length) return false;
        
        return keys1.every(key => deepEqual(obj1[key], obj2[key]));
    }</code></pre>
    
                <h3>Bug #4: Not Handling Async Errors</h3>
                <pre><code>// Bug: Unhandled promise rejection
    async function fetchData() {
        const response = await fetch('/api/data'); // Might fail!
        return response.json();
    }
    
    // Fix: Always use try-catch with async/await
    async function fetchData() {
        try {
            const response = await fetch('/api/data');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Failed to fetch:', error);
            return null; // Graceful fallback
        }
    }</code></pre>
    
                <h3>Bug #5: Mutating Original Arrays/Objects</h3>
                <pre><code>// Bug: Modifying original array
    const numbers = [1, 2, 3];
    const doubled = numbers;
    doubled.push(4);
    console.log(numbers); // [1, 2, 3, 4] - Original modified!
    
    // Fix: Create copies
    const numbers = [1, 2, 3];
    const doubled = [...numbers]; // Spread operator
    doubled.push(4);
    console.log(numbers); // [1, 2, 3] - Original unchanged
    
    // For objects
    const original = { name: 'John', age: 30 };
    const copy = { ...original }; // Shallow copy
    copy.age = 31;
    console.log(original.age); // 30 - Unchanged</code></pre>
    
                <h3>Bug #6: Type Coercion Surprises</h3>
                <pre><code>// Unexpected behaviors
    console.log('5' + 3);        // '53' (string concatenation)
    console.log('5' - 3);        // 2 (numeric subtraction)
    console.log([] + []);        // '' (empty string)
    console.log([] + {});        // '[object Object]'
    console.log(true + true);    // 2
    
    // Fix: Explicit type conversion
    const str = '5';
    const num = 3;
    console.log(Number(str) + num);  // 8 (correct addition)
    console.log(String(num) + str);  // '35' (correct concatenation)
    
    // Use strict equality
    console.log(0 == false);     // true (loose equality)
    console.log(0 === false);    // false (strict equality)</code></pre>
    
                <div class="tip-box">
                    <h3>Debugging Tips</h3>
                    <ul>
                        <li><strong>Use console.log strategically</strong> - Log variables at key points</li>
                        <li><strong>Use debugger statement</strong> - Pauses execution in DevTools</li>
                        <li><strong>Check the Network tab</strong> - See API calls and responses</li>
                        <li><strong>Read error messages carefully</strong> - They tell you exactly what's wrong</li>
                        <li><strong>Use strict mode</strong> - Add <code>'use strict';</code> at top of files</li>
                        <li><strong>Validate assumptions</strong> - Use <code>typeof</code> to check types</li>
                    </ul>
                </div>
    
                <h2>Your JavaScript Journey: Next Steps</h2>
    
                <p>You've covered an incredible amount of JavaScript—from basic variables to advanced async programming. You
                    now understand:</p>
    
                <ul>
                    <li>How JavaScript executes in the browser</li>
                    <li>Variables, data types, and operators</li>
                    <li>Functions and their various forms</li>
                    <li>Control flow with conditionals and loops</li>
                    <li>Event handling and DOM manipulation</li>
                    <li>Arrays, objects, and data structures</li>
                    <li>Scope, closures, and execution context</li>
                    <li>Error handling and form validation</li>
                    <li>Asynchronous programming with Promises and async/await</li>
                    <li>Modern ES6+ features</li>
                    <li>Performance optimization techniques</li>
                    <li>Security best practices</li>
                    <li>Design patterns and debugging strategies</li>
                </ul>
    
                <p>JavaScript is a vast language that continues to evolve. The fundamentals you've learned here form the
                    foundation, but mastery comes through practice. Here's how to continue:</p>
    
                <h3>Practice Projects to Build</h3>
                <ol>
                    <li><strong>Calculator</strong> - Practice functions and event listeners</li>
                    <li><strong>Todo List</strong> - Learn localStorage and CRUD operations</li>
                    <li><strong>Weather App</strong> - Practice Fetch API and async/await</li>
                    <li><strong>Quiz App</strong> - Work with arrays and conditional logic</li>
                    <li><strong>Form Validator</strong> - Master regex and validation</li>
                    <li><strong>Memory Game</strong> - Practice DOM manipulation and timers</li>
                    <li><strong>Shopping Cart</strong> - Combine objects, arrays, and state management</li>
                </ol>
    
                <h3>Resources for Continued Learning</h3>
                <ul>
                    <li><strong>MDN Web Docs</strong> - The definitive JavaScript reference</li>
                    <li><strong>JavaScript.info</strong> - Comprehensive modern JavaScript tutorial</li>
                    <li><strong>Browser DevTools</strong> - Your debugging companion</li>
                    <li><strong>GitHub</strong> - Read other developers' code</li>
                    <li><strong>CodePen/JSFiddle</strong> - Experiment with code online</li>
                </ul>
    
                <div class="info-box">
                    <p><strong>Remember:</strong> Every expert was once a beginner. Don't be intimidated by advanced
                        concepts. Take your time, build projects, make mistakes, debug them, and learn from each experience.
                        JavaScript rewards persistence and curiosity.</p>
                </div>
    
                <p>The web is built with JavaScript. From simple form validations to complex single-page applications, the
                    skills you've learned here power the interactive web. Keep coding, keep learning, and most
                    importantly—keep building.</p>
    
                <p>Welcome to the JavaScript community. Now go build something amazing.</p>
    
            </article>
    
            <footer>
                <p>&copy; 2026 TechTrenches | Beginner-Friendly Tech Tutorials</p>
                <p style="margin-top: 10px; font-size: 0.9em;">Master JavaScript. Master the Web.</p>
            </footer>
        </div>
    
    
    


    










</body>

</html>